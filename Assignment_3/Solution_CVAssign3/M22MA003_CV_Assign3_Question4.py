# -*- coding: utf-8 -*-
"""M22MA003_CV_Assign3_Question4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jlie4368RFZT5WFEifKF_HJPD3bZzryt
"""

import cv2
import numpy as np
from sklearn import svm
from sklearn.metrics import precision_recall_curve, average_precision_score
from imutils.object_detection import non_max_suppression
from google.colab.patches import cv2_imshow
import numpy as np
import os
import matplotlib.pyplot as plt
from skimage.io import imread
from skimage.feature import hog
from skimage.transform import pyramid_gaussian
from sklearn.model_selection import cross_val_score
import glob
from sklearn.svm import SVC
from sklearn.utils import shuffle
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

from google.colab import drive
drive.mount('/content/drive')

img_dir = "/content/drive/MyDrive/testimagedeer"
data_path = os.path.join(img_dir, '*g')
test_data = [cv2.imread(f) for f in glob.glob(data_path)]




img_dir = "/content/drive/MyDrive/Deerimages"
data_path = os.path.join(img_dir, '*g')
deer_data = [cv2.imread(f) for f in glob.glob(data_path)]





img_dir = "/content/drive/MyDrive/Nondeerimage"
data_path = os.path.join(img_dir, '*g')
ND_data = [cv2.imread(f) for f in glob.glob(data_path)]



def findHOG(img, size=(10, 10), block=(2, 2), nbins=9):
    # Resize and convert the image to grayscale
    img = cv2.resize(img, (100, 100))
    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
    
    # Compute HOG features
    hog = cv2.HOGDescriptor(_winSize=(gray.shape[1] // size[1] * size[1],
                                      gray.shape[0] // size[0] * size[0]),
                            _blockSize=(block[1] * size[1],
                                        block[0] * size[0]),
                            _blockStride=(size[1], size[0]),
                            _cellSize=(size[1], size[0]),
                            _nbins=nbins)
    hog_features = hog.compute(gray)
    
    return hog_features

deer_hog_features=[]
nondeer_hog_features=[]
# Compute HOG features for deer images
deer_hog_features = [findHOG(img) for img in deer_data]

# Compute HOG features for non-deer images
nondeer_hog_features = [findHOG(img) for img in ND_data]
(np.asarray(deer_hog_features).shape)

# Concatenate the features and labels into arrays
deer_hog_features = np.array(deer_hog_features)
nondeer_hog_features = np.array(nondeer_hog_features)
X =  np.vstack((deer_hog_features, nondeer_hog_features))
y = np.concatenate((np.ones(len(deer_hog_features)), np.zeros(len(nondeer_hog_features))))

# Shuffle the data
X, y = shuffle(X, y, random_state=50)

# Train an SVM classifier
SVM = SVC(kernel='linear', probability=True, C=1.0)
res = cross_val_score(SVM, X, y, cv=5)
# y=y.reshape(1,-1)
SVM.fit(X,y)

# Evaluate the classifier
print(f"Accuracy:  {res.mean()}")



testdeer_features=[]
# Compute HOG features for deer images
testdeer_features =[ findHOG(img) for img in test_data]

X=np.asarray(testdeer_features)
y=np.ones(len(test_data)-4)
y1=np.zeros(4)
y2=np.concatenate((y,y1))
y_pred=SVM.predict(X)

print(f"precision_score of the model is:::::")
prec=precision_score(y2, y_pred)
print(prec)
print(f"f1_score  of the model is:::::")
f1sc=f1_score(y2, y_pred)
print(f1sc)



# Set the window size, stride and probability threshold
window_size = (300, 300)
stride = 50
p = 0.6

img_dir = "/content/drive/MyDrive/testimagedeer" 
data_path = os.path.join(img_dir, '*.jpg') 
test_files = glob.glob(data_path) 



# Detect deer in each test image using sliding window
for test_file in test_files:
    img = cv2.imread(test_file)
    test_img = cv2.resize(img, (500, 500))
    import cv2
# Initialize a list to store the detected object bounding boxes
    boxes = []

    # Loop over the image using sliding windows
    for y in range(0, test_img.shape[0] - window_size[1], stride):
        for x in range(0, test_img.shape[1] - window_size[0], stride):
            
            # Extract the window and compute the HOG features
            window = test_img[y:y+window_size[1], x:x+window_size[0]]
            fd = findHOG(window)

            # Predict the object label and probability using the SVM classifier
            fd = fd.reshape(1,  fd.shape[0])
            pred = SVM.predict(fd)
            prob = SVM.predict_proba(fd)

            # If the probability is above the threshold and the object is detected,
            # store the bounding box coordinates
            if pred[0] == 1.0 and prob.max() > p:
                box = (x, y, x + window_size[0], y + window_size[1])
                boxes.append(box)

    # Draw the bounding boxes on the image
    for box in boxes:
        cv2.rectangle(test_img, (box[0], box[1]), (box[2], box[3]), (0, 255, 0), 2)

    # Display the result
    cv2_imshow( test_img)
    cv2.waitKey(0)
  
cv2.destroyAllWindows()



